                                                              Базовые типы данных в Python
Название	        |        Описание	                                    Пример	                               Нет
int	            |      Целое число	                   |              33                                            |     Нет
float	          |      Число с плавающей точкой      |             2.48	                                          |     Нет
str	            |      Строка	                       |             “ vasya”, ‘Петя’	                              |     Нет
list	      	      |      Список                        |             [1, 2, ‘Петя’, [“a”, “b”], 6, 3.14]             |     Да
tuple	      	    |      Кортеж                        |             (1, 2, ‘Петя’, [“a”, “b”], 6, 3.14)	            |     Нет
dict	       	    |      Словарь                       |             {“a”: 1, “b”: “string”, “c”: [1, 2, 3]}.        |     Да
set	        	    |      Множество                     |             {1, 4, “c”, 8}	                                |     Да
bool	      	      |      Булевый                       |             True, False	                                    |     Нет
............................................................................................................................................

+	сложение                          .              ==	равно                  .        Десятичная	–1234, 0, 1234
-	вычитание                         .              !=	не равно               .        Двоичная	–0b10011010010, 0b0, 0b10011010010
*	умножение                         .              <	меньше                   .        Восьмеричная	–0o2322, 0o0, 0o2322
/	деление                           .              >	больше                   .        Шестнадцатеричная	–0x4d2, 0x0, 0x4d2
//	целочисленное деление             .              <=	меньше либо равно      .
%	остаток от деления                .              >=	больше либо равно      .
**	возведение в степень              .                                         .
.............................................................................................................................................
https://docs.python.org/3/library/stdtypes.html#str.isalnum
.............................................................................................................................................
index():                                  поиск позиции подстроки методом
 <<<text = "12435514234 ERROR index: big_terrible_mistake message: Ай, случилася беда!"

    template = 'message: '
    index = text.index(template)
    print(text[index + len(template):])

find()                                    поиск позиции подстроки методом
<<< text = "5423534 lajksdfij;jhh абракадабра dfasdfs9d6f7686"

    template = 'message: '
    index = text.find(template)
    if index != -1:
        print(text[index + len(template):])

in:                                       проверка на вхождение. Речь об операторе
<<< text = "12435514234 ERROR index: big_terrible_mistake message: Ай, случилася беда!"
    template = 'message: '
    if template in text:
        index = text.index(template)
        print(text[index + len(template):])

count()                                   Подсчёт числа вхождений
    >>> "абракадабра".count("а")
    5

startswith()                              Первый проверяет, начинается ли строка с того, что мы ожидаем
    >>> "_name".startswith("_")
    True

    name = "internal_attr_2"
    if not name.startswith("_"):
        print(name)
endswith()                                заканчивается ли она тем, чем нужно.
    >>> word = "мышь"

    if word.endswith("ь"):
    print("Это существительное женского рода:", word)

islower()                                 проверяет, все ли символы строки являются строчными:
    >>> "abcde".islower()
    True

isupper()                                 проверяет, все ли символы строки являются прописными:
    >>> "ABC".isupper()
    True

istitle()     проверяет, начинается ли строка с заглавной буквы и следуют ли за ней строчные:
    >>> "Незнайка".istitle()
    True

isnumeric()                               проверяет, состоит ли представленная строка только из цифр:
    >>> "12345".isnumeric()
    True

isalpha()                                 проверяет, наоборот, не содержит ли строка чего-либо помимо букв алфавита (любого):
    >>> "абвгдсCDEF".isalpha()
    True

split()                                   который позволяет разбивать строку на части,
    >>> "А роза упала на лапу Азора".lower().split("а")
    ['', ' роз', ' уп', 'л', ' н', ' л', 'пу ', 'зор', '']

removesuffix():                           ищет конкретную последовательность в начале строки и удаляет её
    >>> "авбвааббв Три слона на баобабе бббаааввв".removeprefix("абв")
    'авбвааббв Три слона на баобабе бббаааввв'

lower()                                   делает буквы меньше 
    >>> "пРивЕт от пАдоНкаФФ".lower()
    'привет от падонкафф'

casefold()                                Он возвращает все символы Юникода в виде, подходящем для сравнения, и это не всегда просто маленькие буквы
    >>> "а" == "А".casefold()
    True

    >>> "Фраза с БОЛЬШИМИ буквами".casefold()
    'фраза с большими буквами'

upper()                                   превращающий все буквы строки в прописные:
    >>> "Отдай мой пирожок!".upper()
    'ОТДАЙ МОЙ ПИРОЖОК!'

replace()                                 Он позволяет заменить все вхождения указанной строки на любую другую:
    >>> "У коня четыре ноги, а у машины - четыре колеса".replace("четыре", "4")
    'У коня 4 ноги, а у машины - 4 колеса'

join()                                    cоединяет элементы списка в одну строку, добавляя указанный разделитель
    >>> splitted = "Вася нехороший человек занял три рубля и отказывается отдавать!".split()
    >>> ", блин, ".join(splitted)
    'Вася, блин, нехороший, блин, человек, блин, занял, блин, три, блин, рубля, блин, и, блин, отказывается, блин, отдавать!'
format()                                   используется для форматирования строк. Он позволяет вставлять значения в строки, используя фигурные скобки {} как плейсхолдеры для значений.
    >>> "Пробег автомобиля с госномером {} составляет {} километров.".format("Л666АЙ77", 30000)
    'Пробег автомобиля с госномером Л666АЙ77 составляет 30000 километров.'

    >>> "A {1} has {0} legs and a {2} has {0} legs. So what's the difference between a {1} and a {2}?".format(4, "cat", "dog")
    "A cat has 4 legs and a dog has 4 legs. So what's the difference between a cat and a dog?"

len()                                        считает строки 
       a = "12312"
      print(len(a))
     Ответ 5

input()                                      вводить текст
   name = input("Введите ваше имя: ")
    print(f"Приветствую, {name}!")

end                                          чтобы управлять тем, что выводится в конце строки
    print("Эта строка плавно переходит", end="")
    print(" в следующую строку.")

sep                                          позволяет указать строку
 print(1, 2, 3, 4, 5, 6, 7, sep = "|")
  1|2|3|4|5|6|7

round()                                       Округляет

bin()                                         работает только с целыми числами

Деление
# Остаток от деления на 5 
x % 5 

# Целочисленное деление
x // 5

Генераторы списков / словарей
[x * 2 for x in range(0, 10) if x != 5]
a = [x * 2 if x == 5 else x for x in range(0, 10)]
{item[0]: item[1] * 2 for item in dct.items()}

Замыкание
def closure_example():
    x = 5

    def inner():
        print(x)

    return inner
Декораторы
# Простой декоратор
def my_decorator(my_func):

    def inner():
        print('Decorator starts...')
        my_func()
        print('Decorator finishes...')

    return inner


# Декоратор для функции с параметрами
def my_decorator_with_params(my_func):

    def inner(*args, **kwargs):
        print('Decorator starts...')
        my_func(*args, **kwargs)
        print('Decorator finishes...')

    return inner

# Использование декоратора
@my_decorator
def print_hi():
    print('Hi!')

decorated_func = my_decorator(print_hi)
decorated_func()

# Использование декоратора для функции с параметрами
@my_decorator_with_params
def adder(**nums):
    print(sum(nums.values()))


print_hi()
adder(a=1, b=2)



Оператор Match
match command:
    case "quit":
        quit()
    case "reset":
        reset()
    case unknown_command:
        print (f"Unknown command'{unknown_command}'")


Сортировки и фильтры
sorted(lst, key = lambda x: x % 2 == 0)
filtered_lst = list(filter(lambda x: x % 2 == 0, lst))
filtered_dict = dict(filter(lambda item: 'O' in item[1], dct.items()))



Обработка исключений
try:
    f.write('Hello')
except io.UnsupportedOperation as e:
    print('UnsupportedOperation!')
finally:
    print('Releasing resources')
    f.close()


Контекстный менеджер
with open('1.txt', 'w') as f:
    f.write('Hello!')


Встроенные библиотеки
sys, os, os.path, time, datetime, random, collections, json, unittest, re, hashlib, bz2, gzip, tarfile, zipfile


Регулярные выражения
res = re.search('Start(\d+)en(\w)', 'Start123end456')
a = res[0]
# re.match() ищет с начала строки
# re.search() - по всей строке
# re.findall() - только список групп


Виртуальное окружение
source my_project/venv/bin/activate
deactivate
Json
# Создаем json-строку из словаря.          |      # Парсим строку в json
dct = {1: 'One', 2: 'Two'}.                |        my_str = '{"1": "One", "2": "Two"}'
my_json = json.dumps(dct, indent=4).       |        my_json = json.loads(my_str)

Локаторы в Selenium
class By:
    """
    Set of supported locator strategies.
    """

    ID = "id"
    XPATH = "xpath"
    LINK_TEXT = "link text"
    PARTIAL_LINK_TEXT = "partial link text"
    NAME = "name"
    TAG_NAME = "tag name"
    CLASS_NAME = "class name"
    CSS_SELECTOR = "css selector"


Добавление элементов. Разбор функций, которые добавляют элементы в массив: append(), insert() и extend().
Удаление элементов. Разбор функций, которые удаляют элементы из массива: remove(), pop() и clear().
Получение индекса элемента. Разбор функции, которая возвращает индекс искомого элемента в массиве.
Сортировка. Разбор функции, с помощью которой можно отсортировать массив.

map() — функция, предназначенная для применения функции к каждому элементу итерируемого объекта. Это полезный инструмент для быстрой и эффективной обработки коллекций данных без необходимости писать явные циклы.

filter()— позволяет фильтровать элементы итерируемого объекта на основе предоставленного условия. Это удобный способ извлечь подмножество данных, соответствующее определенным критериям.

zip() — эффективное средство для объединения двух или более итерируемых объектов. Особенно полезна, когда нужно параллельно итерировать несколько коллекций или объединить их в словарь или другую структуру данных.

any() и all() — функции, предоставляющие быстрые проверки истинности элементов коллекции. Они полезны для быстрой оценки условий, основанных на содержимом коллекций.


# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня


class User:
   login = 'user_login'
   role = 'Python Developer'


print(User.__dict__)

# {'__module__': '__main__', 'login': 'user_login', 'role': 'Python Developer', '__dict__': <attribute '__dict__' of 'User' objects>, '__weakref__': <attribute '__weakref__' of 'User' objects>, '__doc__': None}

getattr()	Возвращает значение атрибута
экземпляра или класса
setattr()	Устанавливает или изменяет значение
атрибута экземпляра или класса
hasattr()	Проверяет наличие атрибута
в экземпляре или классе
delattr()	Удаляет локальные атрибуты
экземпляра или атрибуты класса
isinstance()	Выполняет проверку соответствия
типа объекта и указанного класса

Пример
«магического»
метода	Описание метода	Когда может пригодиться?
__len__()	Позволяет определить вызов функции len() для объекта класса. В данном методе мы будем самостоятельно определять алгоритм вычисления этой длины и что в принципе подразумеваем под длиной объектов нашего класса.	Например, если наши объекты представляют упорядоченное хранилище данных и мы хотим реализовывать различные операции между такими объектами при этом проверяя соответствие их длин.
__add__()	Позволяет определить оператор + для объектов класса. Обратимся к популярному в наших примерах классу Dataset: мы могли бы складывать разные объекты этого класса, если бы определили этот «магический» метод в нашем классе.	Позволит упростить интерфейс работы с объектами для конечного пользователя. Например, мы разработали сложную библиотеку для матричных вычислений и при этом хотим, чтобы пользователь смог привычным ему образом оперировать с объектами.
__eq__()	Определяет оператор == для объектов класса, благодаря которому мы можем сравнивать объект	Например, даже если наш класс — простейшая интерпретация типичного класса Пользователь, определив такую операцию, мы сможем находить дубликаты, поскольку будем сравнивать уже не ссылки на объекты класса, а нечто иное — то, что мы сами определим (вероятнее всего, это будет проверка на идентичность значений атрибутов).
__bool__()	Позволяет определить вызов функции bool() применительно к объектам нашего класса.	Определив функцию bool, мы сможем использовать экземпляры наших классов в if-elif-else statement так, как мы, например, выполняем условие, если список не пуст. Нам достаточно написать if my_list, не проверяя его длину. Мы сможем применять такую же конструкцию к нашим объектам — если, например, у нас есть какой-то очень значимый атрибут, и мы хотим, чтобы условие if my_object выполнялось только тогда, когда этот атрибут существует или имеет какое-то определенное значение.
